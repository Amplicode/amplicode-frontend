## Table of Contents

- [**Newcomer's Guide**](#newcomers-guide)
  - [Development Environment](#development-environment)
  - [Code Style & Conventions](#code-style)
  - [How to Commit Your Work](#commit)
- [**Reference Materials**](#reference)
  - [Generated Project Structure](#generated-structure)
  - [Generators](#generators)
  - [Generated TypeScript Types](#generated-types)

## Newcomer's Guide <a name="newcomers-guide"></a>

### Development Environment <a name="development-environment"></a>

#### Requirements

- Node.js version 14.18.1 or higher
- Npm version 7 (Note, that different npm version 6 or 8 may be causing an issue)

#### Project Bootstrap

Perform npm install and lerna bootstrap:

```
npm install
npm run lerna bootstrap --no-audit
```

#### Database

Install [PostgreSQL](https://www.postgresql.org/download/).

Setup user and database. You can use pgAdmin (graphical administration utility) or psql (PostgreSQL CLI).

- Create user `cuba` with password `cuba`. Set privilege `LOGIN` for the new user.
- Create database with `petclinic` name.

psql example:

```
sudo -u postgres psql
postgres=# create database "petclinic";
postgres=# create user cuba with encrypted password 'cuba';
```

#### Backend

Backend repo for `example-app`: https://github.com/Amplicode/amplicode-mvp-petclinic

Run backend:

```
./mvnw clean spring-boot:run
```

#### Frontend

Re-generate and start `example-app`:

```
npm run bootstrap-react-app
npm run start-react-app
```

### Code Style & Conventions <a name="code-style"></a>

#### File naming

1. If the file contains a React component - use `PascalCase`, i.e. the same case that you use to name the component itself. E.g. `MyComponent.tsx`, `MyComponent.css`.
2. If the file contains a single function - use `camelCase`, i.e. the same case that you use to name the function itself. E.g. `myFunction.ts`.
3. Use `snake-case` everywhere else. E.g. `some-file.ts`.
4. Files generated by Create React App doesn't seem to follow a consistent naming convention. Leave them as they are.

#### Cross-platforming

When you are working with code, you need to adhere to several recommendations in order for the app to work correctly on both UNIX and Windows OS:

1. Remember that Windows uses "\\" symbol as path separator, but UNIX uses "/". For this reason, you need to use "path" package when you work with paths in code:

```
Examples:

// wrong
const examplePath = 'my/test/directory';

// correct
const examplePath = path.join('my', 'test', 'directory');
```

2. Avoid using CLI commands which depend on OS, like 'mkdir -p', 'rm -rf', etc. Instead, use npm packages with CLI that have the same functionality:

```
Examples (package.json scripts):

// wrong
"clean": "rm -rf dist && rm -rf dist-transpiled",
"dist": "npm run compile && mkdir -p dist-browser && browserify --standalone cuba dist-node/cuba.js > dist-browser/cuba.js"

// correct
"clean": "rimraf dist && rimraf dist-transpiled",
"dist": "npm run compile && mkdirp dist-browser && browserify --standalone cuba dist-node/cuba.js > dist-browser/cuba.js"
```

3. When you are working with shell scripts, you need to provide `.sh` script for UNIX users and `.bat` for Windows users. Also, you need to implement logic of running `.sh` scripts for UNIX users, and `.bat` for Windows users.

#### TypeScript

##### Use Semantically Correct Idioms

Nullish checking:

```typescript
// wrong
if (foo) {
}

// correct
if (foo != null) {
}
```

Nullish coalescing:

```typescript
// wrong
const foo = bar || baz;

// correct
const foo = bar ?? baz;
```

Optional chaining:

```typescript
// wrong
const foobar = foo && foo.bar && foo.bar.baz;

// correct
const foobar = foo?.bar?.baz;
```

##### Classes

Extract **static utility methods** / **methods not using class state** into separate functions.

```javascript
// wrong
class SomeClass {
  static staticMethod = () => {};
  methodNotUsingState = () => {};
}

// correct
class SomeClass {}
staticMethod = () => {};
methodNotUsingState = () => {};
```

Bind methods to a class using an arrow function

```javascript
// wrong
class SomeClass {
  SOMETHING = "SOMETHING";
  getSomething() {
    return this.SOMETHING;
  }
}
const { getSomething } = new SomeClass();
getSomething(); // Error

// correct
class SomeClass {
  SOMETHING = "SOMETHING";
  getSomething = () => {
    return this.SOMETHING;
  };
}
const { getSomething } = new SomeClass();
getSomething(); // OK
```

Store class names must be singular

```javascript
// wrong
class ScreensStore {
  // store implementation
}

// correct
class ScreenStore {
  // store implementation
}
```

##### Semicolons

Semicolons are required at the end of a statement. 

```
const screens = useScreens();
```

> While omitting the semicolon will work in most cases, there is [one case](https://stackoverflow.com/a/1169596/16487129) that will be interpreted not as intended when the semicolon is missing. Instead of always keeping this use case in mind, we prefer to just put semicolons at the end of each statement.

Also in types and interfaces:

```
// wrong:
interface MyInterface {
  someString: string,
  someNumber: number
}
interface MyInterface2 {
  someString: string
  someNumber: number
}

// correct:
interface MyInterface {
  someString: string;
  someNumber: number;
}
```

##### E2E Tests

E2E tests should resemble real user interaction as closely as practicable. Therefore **do not access elements by ids, class names, etc.** Use `@react/testing-library` and its query methods instead. Consult this [priority list](https://testing-library.com/docs/queries/about#priority) to understand which methods are preferable.

### How to Commit Your Work <a name='commit'></a>

#### Conventional Commits

We are using conventional commits. Conventional commits allow generating changelogs and simplify managing of semantic versioning. See [this article](<](https://www.conventionalcommits.org/en/v1.0.0/#summary)>) for a short overview of the methodology.

Our commits have the following structure:

```
type(scope): short description #issueNumber

affects: list of libs

long description

BREAKING CHANGE:
description of breaking change
```

Example:

```
 feat(React): support hooks #4

    affects: @cuba-platform/react-core, @cuba-platform/react-ui, @cuba-platform/front-generator

    Added support for hooks.
    Added utility and convenience hooks:
     - useMainStore
     - useInstance
     - useCollection
    Added support for hooks.
    Added utility and convenience hooks:
     - useMainStore
     - useInstance
     - useCollection
     - useReaction
    Added `entity-management-hooks` template with hooks-based entity
    editor as a proof of concept.

    BREAKING CHANGE:
    Increased minium version requirements for dependencies:
     - mobx-react:       ^6.2.2
     - react-router-dom: ^5.2.0
```

When making a commit, it is highly suggested to use `npm run commit` instead of `git commit` or IDE. This will launch [Commitizen CLI](https://github.com/commitizen/cz-cli). This interactive tool will walk you through creating a conventional commit message. Most importantly, it will automatically specify which packages are affected, which is important for both changelogs and versioning.

> NOTE: Don't use `ISSUES CLOSED` as it will automatically close the issue upon merge, which is usually not what we want (issue has to be tested, etc.).

Example of an interactive prompt:

```
? Select the type of change that you're committing: feat:     ✨  A new feature (note: this will indicate a release)
? Denote the scope of this change:
? Write a short, imperative tense description of the change:
 support bean validation
? Provide a longer description of the change (optional). Use "|" to break new line:

? List any BREAKING CHANGES (if none, leave blank):

? List any ISSUES CLOSED by this change (optional). E.g.: #31, #34:

? The packages that this commit has affected (0 detected)
 (Press <space> to select, <a> to toggle all, <i> to invert selection)
❯◯ @haulmont/jmix-front-generator
 ◯ @haulmont/jmix-react-core
 ◯ @haulmont/jmix-react-ui
 ◯ @haulmont/jmix-rest
 ◯ test-puppeteer
```

We use the following **change types**:

```
feat:     ✨  A new feature (note: this will indicate a release)
fix:      🛠  A bug fix (note: this will indicate a release)
docs:     Documentation only changes
style:    Changes that do not affect the meaning of the code
(white-space, formatting, missing semi-colons, etc)
refactor: A code change that neither fixes a bug nor adds a feature
perf:     A code change that improves performance
test:     Adding missing tests
chore:    Changes to the build process or auxiliary tools
            and libraries such as documentation generation
revert:   Revert to a commit
WIP:      Work in progress
```

Note that change type affects whether the commit message will be included to changelog:

- `feat` and `fix` are always included
- other types are included if commit contains breaking changes

The list of available **scopes** can be found in `commitlint.config.js` file under `rules` -> `scope-enum`. Scope is optional.

Short description should use imperative tense.

Correct:

```
feat: add high-contrast theme #42
```

Wrong:

```
feat: added high-contrast theme #42
```

Long description is optional.

**IMPORTANT:** Before you make a commit with `BREAKING CHANGES`, discuss it with your team lead. Breaking changes means major release, we might want to schedule it appropriately.

Commit message should contain github issue number (if any).

Correct:

```
feat: add high-contrast theme #42
```

Wrong (will cause GitHub to automatically close the issue once PR is merged):

```
feat: add hight-contrast theme

ISSUES CLOSED: #42
```

#### Commit Workflow

0. Note! If you made some changes in templates (generators) which reflected in generated code you must update (regenerate) example app as well `npm run bootstrap-react-app`.

1. Create a feature branch from `master`. Branch name should be `{initials}/{type}/{issueNumber}/{shortDescription}`, e.g. `pv/feat/34/bean-validation`:

   - `initials` are the first letters of author's first and last name. If the initials are already used by another team member - add additional letters (e.g. first letter of middle name).
   - `type` is type of change, see [Conventional Commits](#conventional-commits).

2. Commit your work and push your branch. Usually one issue = one commit, but you may want to split the changes into several commits to make review easier (for example, you may want to make separate commits for changing documentation sources and updating generated documentation).

3. Create a Pull Request and add reviewers. You need to get at least 1 approval before you can merge your request. If you have some code comments from reviewers you need to fix that (point 4). After that, you need to press "resolve conversation" button and re-request review.

4. You may need to make some changes after Peer Review. Since commits might affect changelog, it's best to squash the changes into your initial commit(s), for example by using [fixup and autosquash](https://stackoverflow.com/a/3828861) and force-pushing your feature branch. Force-pushing is only allowed for your own feature-branches, never force-push master or release branches.

5. Merge your PR with "Rebase and merge" button and delete source branch after that.

##### Updating your Feature Branch to Latest Master

Don't use **merge**. Use **rebase**. We want linear git history.

```
# in your feature branch
git pull --rebase origin master
```

## Reference Materials <a name='reference'></a>

### Generated Project Structure <a name='generated structure'></a>

```
src/
├─ app/
│  ├─ header/
│  ├─ main/
│  ├─ menu/
│  │  ├─ Menu.css
│  │  ├─ Menu.tsx
│  ├─ login/
│  ├─ screens/
│  │  ├─ home/   
│  │  ├─ owner/
│  │  ├─ pet/
│  ├─ App.css
│  ├─ App.tsx
│  ├─ App.test.tsx
├─ dev/
├─ gql/
├─ core/
│  ├─ addons/
│  │  ├─ addons.ts
│  ├─ i18n
│  │  ├─ en.json
│  │  ├─ i18n-init.ts 
│  ├─ screen-api
│  │  ├─ ScreenTabs.tsx
│  │  ├─ screen-registry.ts
│  ├─ security/
│  │  ├─ security.ts
│  │  ├─ security-store.ts
├─ config.ts
├─ index.css
├─ index.tsx
├─ react-app-env.d.ts
├─ reportWebVitals.ts
├─ setupTests.ts
```

#### Explanation:

- **app** folder is for UI components except generated screens. E.g. login screen, header, etc. This is the code that is most likely to be customized.
- **app/screens** folder is for generated screens. Whatever is added when you click "Add frontend component" in Studio.
- **dev** is for palette, previews, etc. - tooling-related stuff.
- **gql** is for generated TS typings.
- **core** is for generated code that we more or less consider part of framework. Addons config, i18n, screen API, security, etc. This code is less likely to be customized by hand. Some of it might be heavily changed by tooling.

### Generators <a name='generators'></a>

#### Basics and Terminology

`packages/codegen` contains the source code for `@amplicode/codegen` library which is used for code generation (scaffolding). This library uses [Yeoman](https://yeoman.io/), however, in order to extend and reuse functionality we are using functions composition rather than Yeoman's usual approach of class inheritance. This will be covered in more detail in [How to Write a Generator](#how-to-write-a-generator) section. The code is generated from [EJS](https://ejs.co/) templates.

This library can be used as a standalone CLI tool, but most of the time it will be used from Studio. When used as a CLI tool it can interactively ask questions and use the **answers** to resolve interpolations in the templates. Studio will ask these questions using its graphical interface and invoke the generator CLI, passing the base64-encoded answers object as `--answers` **option**. There are other options, for example `--dest` that tells the generator where to put the generated files.

In addition to _answers_ and _options_ generator uses **GraphQL schema**. 

> EJS template + options + answers + GraphQL schema = generated code

A **generator** is a combination of an EJS template and code that is responsible for asking questions and turning the answers, options and GraphQL schema into generated code. For each **client** (e.g. React client, React Native client, etc.) there is always a generator that creates a starter app and zero or more generators that adds the components.

> TIP: use `amplicodegen -h` to see the available clients, generators and options.

#### How to Write a Generator <a name='how-to-write-a-generator'></a>

There is a convention that enables CLI/Studio to discover generators. When you want to add a new generator:

1. Create a new folder in `src/generators/{clientName}/{generatorName}`.
2. Add an EJS template (by convention we put it under the `template` directory).
3. Add `index.ts` file. It should contain:

   - A generator class that extends `YeomanGenerator` and contains a constructor and a single method. By convention this method is called `generate`.
   - An export that looks like this:
     ```
     export {
        YourGeneratorClassName as generator,
        optionsConfig as options,
        allQuestions as params,
        description
     }
     ```

`optionsConfig` is an `OptionsConfig` object that contains available options. `allQuestions` is a `StudioTemplateProperty` array representing all possible questions that can be asked by this generator. `description` will be shown by CLI and Studio.

`generate` method will contain the generator's logic. Since a lot of logic is duplicated between the generators, we are using the following convention to reuse it.

#### Pipelines and Stages

Generally the process of code generation can be viewed as the following **pipeline**:

```
     +-------------+
     | get options |
     +------+------+
            |
            v
   +--------+---------+
   | configure Yeoman |
   +--------+---------+
            |
            v
 +----------+-----------+
 |  get GraphQL schema  |
 +----------+-----------+
            |
            v
     +------+------+
     | get answers |
     +------+------+
            |
            v
+-----------+-----------+
| derive template model |
+-----------+-----------+
            |
            v
     +------+------+
     |    write    |
     +------+------+
```

Let us describe the **stages** of this pipeline:

- `get options`: we tell Yeoman what options are allowed and get the values of those options.
- `configure Yeoman`: set the source and destination directory, register transformations, etc.
- `get GraphQL schema`: for example, read it from file system using file path is provided in options.
- `get answers`: ask questions and get the answers. Or get the answers from options.
- `derive template model`: use answers, options and project model to create a **template model** - a set of data that will be used to resolve interpolations in the template. This stage is kind of like MobX's `@computed`.
- `write`: use the template and template model to resolve the interpolations and write the result to the file system.

To use this pipeline call `defaultPipeline` function in your `generate` method. The arguments:

- `templateDir` - template location.
- `questions` - an array of all possible questions (if your generator is using any).
- `options` - options config (defaults to `commonGenerationOptionsConfig`).
- `stages` - an object containing your custom implementations of stages:
  - `getOptions`
  - `configureGenerator`
  - `getGraphQLSchema`
  - `getAnswers`
  - `deriveTemplateModel`
  - `write`

There are default implementations of stages that are suitable for most cases. Most likely you'll need to customize `getAnswers`, `deriveTemplateModel` and `write`. Implementations of these stages also share some code between themselves. This code is extracted into functions which we put under `src/building-blocks/stages/{stageName}/pieces`. When creating your own reusable functions it is important to give them clear names so that your functions can be easily discovered and reused by fellow developers.

Inside your generator folder, organize your custom code based on the stage it belongs to. For example, put your questions and your implementation of `getAnswers` to `answers.ts`, your `TemplateModel` type and `deriveTemplateModel` implementation to `template-model.ts`, etc. A typical generator folder may look like this:

```
├── answers.ts
├── index.ts
├── options.ts
├── template
│ ├── Cards.tsx.ejs
│ ├── EntityManagementEditor.tsx.ejs
│ ├── EntityManagement.tsx.ejs
│ ├── List.tsx.ejs
│ └── Table.tsx.ejs
├── template-model.ts
└── write.ts
```

If you need to use a different/modified pipeline, write your own analogue of the `amplicodePipeline` function. You can still reuse the default implementation of stages that are relevant to you.

#### Templates

The `template` folder inside generator is used to create templates from which the code will be generated.
Templates are processed using [EJS](https://ejs.co/).
<br>
Template files could be any type,
but to increase code readability for complex files there is an ability to add `.ejs` suffix to a template name.
During the file processing the suffix will be removed.
It means that files `EntityManagementEditor.tsx.ejs` and `EntityManagementEditor.tsx` both will be processed to file
`EntityManagementEditor.tsx` and the only difference is how they will be highlighted in IDE.

#### Template Utilities

You can add `templateUtilities` to your template model in order to use utility functions (case-conversion, etc.) inside your templates. If you do so, your template model type should have a union with `UtilTemplateModel`.

```
export type TemplateModel = CommonTemplateModel & UtilTemplateModel & {
  // ...
}

export const deriveTemplateModel = (
  answers: Answers, projectModel: ProjectModel, gen: YeomanGenerator, options: Options
): TemplateModel => {
  // ...
  return {
    // ...
    ...templateUtilities
  };
}
```

#### Testing Your Changes Manually

Generators should be tested from both CLI and Amplicode Studio. In either case the codegen library should be built first:

```
cd packages/codegen
npm run build
```

##### Testing from CLI

Install the local codegen build:

```
cd packages/codegen
npm i -g .
```

How you can use the generator in CLI using `amplicodegen` command. Running it without arguments displays the usage info.

```
$ amplicodegen

Usage: amplicodegen [command] [options]

Options:
  --custom-generator-paths <paths...>        Use custom generators from the filesystem.
  -v, --version                              output the version number
  -h, --help                                 display help for command

Commands:
  list [options]                             List all available clients and their clients
  react-typescript:addon [options]           Generates react-typescript addon
  react-typescript:app [options]             Generates react-typescript app
  react-typescript:entity-list [options]     Generates react-typescript entity-list
  react-typescript:entity-details [options]  Generates react-typescript entity-details
  help [command]                             display help for command
```

There is a couple of special commands such as `list` or `help`, the rest of the command are generators. These commands follow the pattern `client-name:generator-name`.

You can display help for a given command:

```
$ amplicodegen help react-typescript:entity-list
Usage: amplicodegen react-typescript:entity-list [options]

Generates react-typescript entity-list

Options:
  -d, --dest [dest]          destination directory
  -s, --schema [schema]      specify path to GraphQL schema
  -a, --answers [answers]    fulfilled params for generator to avoid interactive input in serialized JSON string
  -b, --verbose              log out additional info about generation process
  -f, --dirShift [dirShift]  directory shift for html imports e.g ../../
  -h, --help                 display help for command
```

Example of generator invocation in CLI (it's multiline to improve readability, note that using \ to make multiline commands won't work on Windows):

```
amplicodegen react-typescript:entity-details \
 --answers eyJjb21wb25lbnROYW1lIjoiUGV0TGlzdCIsInNob3VsZEFkZFRvTWVudSI6dHJ1ZX0= \
 --schema ./schema.graphql \
 --dest ../example-app/src/app/petEditor \
 --dirShift ../../
```

`--answers` is base64-encoded answers object. For example, if you need to provide a string answer `componentName` and a boolean answer `shouldAddToMenu`:

```
const answers = {
  componentName: 'PetList',
  shouldAddToMenu: true,
};
const encodedAnswers = btoa(JSON.stringify(answers));
```

##### Testing from Amplicode Studio

You'll need IntelliJ IDEA Ultimate.

0. Install Studio:
   - Download the latest build of Amplicode Studio (see team wiki for the link).
   - In IDE navigate to `File` -> `Settings` -> `Plugins`
   - Click cogwheel icon and select 'Install plugin from disk`
2. Open [backend project](https://github.com/Amplicode/amplicode-mvp-petclinic) in Studio.  
3. Navigate to `frontend/generation`.
4. npm install the local codegen build, for example:
   ```
   npm i /home/me/amplicode-frontend/packages/codegen
   ```
4. Invoke Gradle task `listGenerators` in the backend project ("Gradle" panel on the right, `frontend` -> `Tasks` -> `npm` -> `listGenerators`).
5. Restart Studio.

Now you can create screens using Studio interface (`Ctrl + Shift + A` -> type "Frontend Component").

### Generated TypeScript Types <a name="generated-types"></a>

We are using [@graphql-codegen/gql-tag-operations-preset](https://www.graphql-code-generator.com/docs/presets/gql-tag-operations) to generate TypeScript types based on GraphQL operations and schema. Generated types are located in `src/gql` and we install them as a local package in order for them to be available in any place of the application by the same path. Read above link for more details.

**There is a caveat!** Generated TypeScript types are using `@graphql-typed-document-node/core` package. It is a transitive dependency of `@apollo/client`. When using npm 7 it is installed on top level and is therefore usable by `src/gql`. When using npm 8 it is installed in `node_modules` inside `@apollo/client` folder and is therefore inaccessible. As a workaround, we are adding it as a dev dependency to `src/gql`. When updating `@apollo/client` to a version that uses new major version of `@graphql-typed-document-node/core` we should manually update mentioned dev dependency in the template.

### Collection EJS Templates (List, Cards, Table)

Codegen has an ability to generate three types of screens for collection of entities - List, Cards and Table.

`List` and `Cards` templates provide ability to generate collection components in three modes.
Variant of component should be configured in `mode` variable (passed to the template from `templateModel`):

* `mode = 'edit'` - default mode which is used when collection items could be edited via additional
  component (`itemComponentName`)
* `mode = 'view'` - no additional item component provided
* `mode = 'view with details'` - here item component is the component that show item details without ability to edit


Beside mode, there are additional options for template config:

* `withDeleteAction` - defines if delete button should be on screen or not. Yes if `deleteMutationName` and
  `deleteMutationString` provided
* `withItemComponent` - defines if item component defined and passed in `itemComponentName`

### Variants of Generated Screens

Codegen provides several variants of crud screens generation, which are used in Amplicode Studio. 
Examples of CLI commands for each variant could be found at [scripts/bootstrap-app](scripts/bootstrap-app) folder.

#### Entity Management
Consist of `collection screen` with actions (edit, delete) and `editor screen`. 

Generator: `react-typescript:entity-management`

Expected answers:
- `listComponentName`name of collection component
- `itemComponentName` name of editor component
- `route`component route (i.e. component will be available at localhost:3000/**pet-list**, if `route` is set to `pet-list`)
- `type` type fo generated collection component, could be `list`, `cards` or `table`; this answer is optional,
  by default will be generated `cards` type of collection
- `shouldAddToMenu` defines do we need to add or not screens to menu
- `mode` an optional answer, defines which type of editor should be used,
  available options `edit`, `view`, `view with details`; default value, and this value should be used for management 
  generation is `mode: 'edit'` 
- `listQuery` GraphQL query to load list of entities
- `detailsQuery` GraphQL query to load entity by id
- `deleteMutation` GraphQL query to delete entity
- `upsertMutation` GraphQL query to create or update entity
- `filterByArguments` an optional parameter that includes filter component in collection screens, 
filtering will be available by arguments listed in answers
  
Command example: [pet-management-list.js](scripts/bootstrap-app/generate-management/pet-management-list.js)

Generated screens: [PetList.tsx](example-app/src/app/screens/management/PetList.tsx), 
[PetListEditor.tsx](example-app/src/app/screens/management/PetListEditor.tsx)  

#### Read Only Collection
Consist of `collection component` without actions and `entity details` component. <br>
This variant is similar with [management](#entity-management) described above, 
but instead of `entity editor` is used `entity details` component (defined by answer `mode: 'view with details'`).

Generator: `react-typescript:entity-management`

Expected answers (description could be seen above, in [Management](#entity-management) section):
- `listComponentName`
- `itemComponentName`
- `route`
- `type`
- `shouldAddToMenu`
- `listQuery`
- `detailsQuery`
- `mode` should be `view with details` for readonly collection variant

Command example: [pet-list-readonly.js](scripts/bootstrap-app/generate-readonly-collection/pet-list-readonly.js)

Generated screens: [ReadOnlyPetList.tsx](example-app/src/app/screens/readonly-collection/ReadOnlyPetList.tsx),
[ReadOnlyPetListDetails.tsx](example-app/src/app/screens/readonly-collection/ReadOnlyPetListDetails.tsx)

#### Standalone Collection
Consist of `collection component` with actions.

Generator: `react-typescript:entity-list`

Expected answers (description could be seen above, in [Management](#entity-management) section):
- `componentName`
- `route`
- `type`
- `shouldAddToMenu`
- `query` GraphQL query to load list of entities
- `mutation` GraphQL query to delete entity
- `mode` should be `edit` for standalone collection variant

Command example: [owner-list-standalone.js](scripts/bootstrap-app/generate-standalone-collection/owner-list-standalone.js)

Generated screen: [StandaloneOwnerList.tsx](example-app/src/app/screens/standalone-collection/StandaloneOwnerList.tsx)

#### Standalone Editor
Consist of `editor component`. <br>
Standalone editor and standalone details variants are created using the same generator (`entity-details`). 
If `mutation` answer passed to generator, then `editor` screen will be generated, in other case will be created `details`.

By clicking on a menu, standalone editor is opened in 'entity creation' mode. 'Update' mode doesn't available from a menu,
but could be available via direct link. For example, for standalone owner editor, which available from menu by route 
[http://localhost:3000/standalone-owner-editor](http://localhost:3000/standalone-owner-editor), 
'update' mode could be available by adding owner `id` (here id is equal to `1`) at the end of the 
url [http://localhost:3000/standalone-owner-editor/1](http://localhost:3000/standalone-owner-editor/1)

Generator: `react-typescript:entity-details`

Expected answers (description could be seen above, in [Management](#entity-management) section):

Command example: [owner-editor-standalone.js](scripts/bootstrap-app/generate-standalone-editor/owner-editor-standalone.js)
- `componentName`
- `refetchQueryName` GraphQL query that should be refetched after item will be created or modified
- `route`
- `shouldAddToMenu`
- `query` GraphQL query to load entity
- `mutation` GraphQL query to create or update entity

Generated screen: [StandaloneOwnerEditor.tsx](example-app/src/app/screens/standalone-editor/StandaloneOwnerEditor.tsx)

#### Standalone Entity Details
Consist of `entity details component`. <br>
Variant is similar with `standalone editor`. More details about difference in [Standalone Editor](#standalone-editor) section.

Standalone entity details screen could be added to menu, but page will show 'Request failed' message on open. This is because 
`entity details` always required entity `id` for proper work, but it is not possible to add it on a menu url due generation.
So we need to add entity `id` (here id is equal to `1`) in url manually. For example for 
[http://localhost:3000/standalone-pet-details](http://localhost:3000/standalone-pet-details) valid url will be
[http://localhost:3000/standalone-pet-details/1](http://localhost:3000/standalone-pet-details/1).


Generator: `react-typescript:entity-details`

Command example: [owner-editor-standalone.js](scripts/bootstrap-app/generate-standalone-editor/owner-editor-standalone.js)
- `componentName`
- `route`
- `shouldAddToMenu`
- `query` GraphQL query to load entity

Command example: [pet-details-standalone.js](scripts/bootstrap-app/generate-standalone-details/pet-details-standalone.js)

Generated screen: [StandalonePetDetails.tsx](example-app/src/app/screens/standalone-details/StandalonePetDetails.tsx)

#### Lookup
Consist of a bit modified `collection component`. <br> 
At this moment only `cards` type of collection is supported in lookup screen.

Lookup screen usually is used as part of editor component
[for one-to-many relation field selection](#link-Lookup-Screen-with-One-To-Many-Form-Field). 
By default `shouldAddToMenu = 'false'`, but could be set to `true` for testing and sampling purposes.

Generator: `react-typescript:entity-lookup`

Expected answers (description could be seen above, in [Management](#entity-management) section):
- `componentName`
- `route`
- `query` GraphQL query to load list of entities

Command example: [pet-lookup-cards.js](scripts/bootstrap-app/generate-lookup/pet-lookup-cards.js)

Generated screen: [PetLookupCards.tsx](example-app/src/app/screens/lookup/PetLookupCards.tsx)

### Localization
Based on `react-intl` library.

#### I18nProvider
Contains all the logic for setting up localization. `I18nProvider` consists of `I18nStoreProvider`, `StaticMessagesProvider`, `I18nApiProvider` and other addon messages Providers.

##### I18nProvider tsx tree:
```jsx
<I18nStoreProvider localeConfigs={localeConfigs} defaultLocale="en">
 <AnyAddonMessagesProvider> // Provide static messages specific to an addon
  <StaticMessagesProvider>
    <I18nApiProvider>
     {children}
```

#### I18nStoreProvider
Providing `I18nStore`. Place for configure available locales.

#### I18nStore
Mobx store using for working with localization messages and available locales.

#### StaticMessagesProvider
Loads static messages to `I18nStore`.

#### I18nApiProvider
Connects `I18nStore` with `react-intl` library.

#### Addon metadata.tsx
The file is in the root of an addon. Contain information on how to mount addon Providers, menu items, and screens.
```jsx
import Component from "...";

export default {
  mountedComponents: [
    {
      element: <ComponentThatLoadsSomething prop1="value1" />, // Using JSX provides possibility to setup props
      mountingPoint: 'ROOT', // Studio knows that it resolves to src/index.tsx 
      below: 'ApolloProvider'
    },
    {
      element: <ComponentThatProvidesAddonSpecificI18nMessages>,
      mountingPoint: 'I18N', // Studio knows that it resolves to src/core/i18n/I18nProvider.tsx (or perhaps to a different path depending on frontend version)
      above: 'StaticI18nMessagesProvider'
    }
  ],
  screenItems: [
    {
      key: 'screen-id',
      captionKey: "screenCaptionId",
      component: <ComponentScreen />
    }
  ],
  menuItems: [
    {
      key: 'addon-name_some-key-unique-within-addon',
      screenId: 'screen-id' // Optional, defaults to key value
    }
  ] // NOTE: This is a simple case with a single menu item, but we should also support nested menu items here. I.e. an addon can add a top level menu item "User Management" with second level menu items "Item1", "Item2",  "Item3"
} as AddonMetadata;
```

### Link Lookup Screen with One To Many Form Field

At this moment we don't have ability to link lookup screens with one-to-many fields in the editor due to app generation. 
Lookup screens are created separately with `entity-lookup` generator. When example app is bootstrapped 
such screens could be mapped to lookup field using code below (example based on `PetListEditor.tsx`) 

```jsx
import {PetTypeLookup} from "../lookup/PetTypeLookup";
import {OwnerLookup} from "../lookup/OwnerLookup";

...

      <Form.Item name="owner" label="Owner">
        <EntityLookupField
          getDisplayName={getOwnerDTODisplayName}
          label="Owner"
          // TODO Uncomment the code and specify the list component
          lookupComponent={OwnerLookup}
        />
      </Form.Item>

      <Form.Item name="type" label="Type">
        <EntityLookupField
          getDisplayName={getPetTypeDTODisplayName}
          label="Type"
          // TODO Uncomment the code and specify the list component
          lookupComponent={PetTypeLookup}
        />
      </Form.Item>

```
